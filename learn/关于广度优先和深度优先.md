# 关于广度优先和深度优先

# 情景说明

> 我们以前常用的日记本、密码箱这些东西，经常使用三位数的那种机械密码锁

![密码](https://raw.gitmirror.com/ByteQuestor/picture/main/pythonLearn/BFSDFS/passwd.png)

> 有时候我们忘记了密码，那么就需要一个一个的试

以下是针对忘记三位数密码锁密码，分别用广度优先和深度优先算法求解的思路及示例：

#  广度优先搜索（`BFS`）求解密码

## 思路

- 广度优先搜索是从起始状态开始，逐层地对状态空间进行搜索。对于三位数密码锁，每个数位可以是0 - 9这10个数字中的一个，总共有1000种可能的密码组合（000 - 999）
- 我们从000开始，将其作为第一层节点放入队列中。然后依次取出队列头部的节点（密码组合），尝试开锁，如果不行，就生成它所有可能的下一层节点（通过改变其中一个数位的值，每次加1或减1，循环到0或9时循环处理），并将这些新节点放入队列尾部，继续这个过程直到找到正确密码或者遍历完所有可能的组合。

## 报告：

### 一、问题描述

> 忘记了三位数密码锁的密码，需要通过算法找出正确密码。

### 二、算法选择
采用**广度优先**搜索算法，因为它能保证在找到目标密码时，所经过的路径是从起始点到目标点的最短路径（在未优化的情况下以节点扩展顺序而言），且能系统地遍历所有可能的密码组合。

### 三、实现过程

1. 创建一个队列，将初始密码组合`“000”`放入队列。
2. 进入循环，只要队列不为空：

- 取出队列头部的密码组合。
- 尝试用该密码组合打开密码锁。
- 如果打开成功，记录下该密码组合作为正确密码并结束搜索
- 如果未成功，生成该密码组合的所有可能的下一层密码组合（通过对每个数位分别进行加1或减1操作，处理边界情况），并将这些新组合放入队列尾部。

### 四、结果
经过 [X] 次尝试，成功找到正确密码为 [具体密码]。在搜索过程中，最多时队列中存储了 [最大队列长度] 个待尝试的密码组合。

### 五、代码

- 优点：一定能找到正确密码（密码就在`000 - 999`范围内），且相对比较有序地遍历所有可能组合，找到的路径相对较优（从起始尝试次数角度）。
- 缺点：需要存储较多的待尝试密码组合在队列中，可能占用较多内存空间，尤其是密码位数增多时，空间复杂度会快速上升。

```python
from collections import deque

def bfs_crack_password(target="999"):
    queue = deque(["000"])  # 初始化队列，从"000"开始
    visited = set()          # 用来记录已访问的密码
    step = 0                 # 记录尝试的步数

    while queue:
        password = queue.popleft()  # 取出队列头部的密码
        step += 1
        print(f"第{step}步：正在尝试密码 {password}")

        # 结束条件
        if password == target:
            print(f"密码破解成功，正确密码是 {password}")
            break

        visited.add(password)

        # 对密码的每一位数字分别进行 +1 或 -1 操作
        for i in range(len(password)):
            for delta in [-1, 1]:  # 两种操作：加1 或 减1
                # 获取当前数字
                current_digit = int(password[i])

                # 计算新数字
                new_digit = (current_digit + delta) % 10

                # 生成新的密码
                new_password = password[:i] + str(new_digit) + password[i + 1:]

                # 如果新密码没有访问过，加入队列
                if new_password not in visited:
                    queue.append(new_password)

# 广度优先
bfs_crack_password()
```



# 深度优先搜索（`DFS`）求解密码

## 思路

- 深度优先搜索是沿着一条路径尽可能深地探索下去，直到无法继续或者找到目标，然后回溯到上一个未完全探索的分支点，继续探索其他分支。
- 对于三位数密码锁，我们可以从某个初始密码组合（比如000）开始，先固定第一位数字，然后对第二位数字进行深度优先搜索（从0到9循环尝试），对于每一个第二位数字确定的情况，再对第三位数字进行深度优先搜索，如此递归下去。如果在某条路径下未找到正确密码，就回溯到上一层，改变上一层的数字继续搜索。

## 报告

### 一、问题描述
> 忘记了三位数密码锁的密码，需要通过算法找出正确密码。

### 二、算法选择

采用深度优先搜索算法，它在某些情况下可能比广度优先搜索更快地找到目标（如果目标在较深的分支且运气较好先探索到该分支），并且不需要像广度优先搜索那样存储大量待尝试的组合（只需记录当前搜索路径上的节点）。

### 三、实现过程

1. 从初始密码组合`“000”`开始。
2. 定义一个递归函数来进行深度优先搜索：

- 对于当前密码组合，尝试用它打开密码锁。
- 如果打开成功，记录下该密码组合作为正确密码并结束搜索。
- 如果未成功，对当前密码组合的下一位数字（从左到右依次处理，先处理第二位数字，然后第三位数字）进行循环改变（从`0`到`9`），并对每一个改变后的新密码组合递归调用该函数继续深度优先搜索。

### 四、结果

经过` [X] `次尝试，成功找到正确密码为 [具体密码]。在搜索过程中，最多时记录了 [最大递归深度] 个当前搜索路径上的密码组合。

### 五、分析

- 优点：不需要大量存储待尝试的密码组合，空间复杂度相对较低（只与递归深度有关）。如果目标在较深的分支且先探索到，可能会较快找到目标。
- 缺点：可能会陷入较深的无效分支，导致搜索时间较长，而且找到的路径不一定是从起始点到目标点的最优路径（从尝试次数角度）

```python
step = 0  # 记录尝试的步数
visited = set()  # 用于记录已经尝试过的密码


def dfs_crack_password(password="000", depth=0):
    global step
    step += 1
    print(f"第{step}步：正在尝试密码 {password}")

    if password == "999":
        print(f"密码破解成功，正确密码是: {password}")
        return password

    if password in visited:
        return None  # 如果已经尝试过这个密码，跳过

    visited.add(password)  # 将当前密码标记为已访问

    if depth == 3:  # 三位数密码，深度达到3说明已经处理完所有位数
        return None

    for i in range(10):
        # 只修改当前位数对应的密码
        new_password = password[:depth] + str(i) + password[depth + 1:]

        # 确保不重复进入已经访问过的密码
        if new_password not in visited:
            result = dfs_crack_password(new_password, depth + 1)  # 递归调用，深入下一位数进行尝试
            if result:
                return result


correct_password = dfs_crack_password()

```

# 关于使用时机

> 广度和深度算法不同，适合的场景也不一样

以当前破解密码为例，无疑是广度优先最合适的，因为三位数的密码，我们根本不知道任何一位的数字

[] [] []

1 [] []



