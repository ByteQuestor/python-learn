# 问题

**[例题2]**（**洛谷`P239`，`kkksc03`考前临时抱佛脚**）这次期末考试，`kkksc03`需要考4科。因此要开始刷习题集，每科都有一个习题集，分别有 `s1，s2，s3，s4 `道题目，完成每道题需要一些时间，可能不能`（A1，A2，...，As1，B1，B2，...，Bs2，C1，C2，...，Cs3，D1，D2，...，Ds4）`

`kkksc03`有一个能力，他的左右两个大脑可以同时计算 2 道不同的题目，但是仅限于同一科。因此，`kkksc03`必须一科一科地复习。

由于`kkksc03`还急着去处理洛谷的BUG，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。

[**输入格式**] 本题包含5行数据：第 1 行，为四个正整数 `s1，s2，s3，s4`。

第2行，为` A1，A2，...，As1` 共 `s1 `个数，表示第一科习题集每道题目所消耗的时间。

第3行，为 `B1，B2，...，Bs2` 共` s2` 个数。

第4行，为 `C1，C2，...，Cs3` 共` s3` 个数。

第5行，为 `D1，D2，...，Ds4` 共` s4 `个数，意思均同上。

[**输出格式**] 输出一行，为复习完毕最短时间。

[**输入输出样例**] 

**输入**

```tex
1 2 1 3
5
4 3
6
2 4 3		
```

**输出**

`20`



# 思路

关于这个题没思路，主要是因为**递归太难**了，但是解决问题并不一定是递归

这个题的本质就是，让我们搞一个最短的时间，而这个最短的时间再细分到各个科目上，就好解决了

```python
5
'''
如果只有一个题目，那么就消耗这么多时间
'''
4 3
'''
如果有两个题目，那么就消耗较长那个题目的时间
'''
6
2 4 3
'''
如果有多个题目，那么需要两两分组，但是两两分组后
两组的和又不能相差太多
如本组数据中，[2 + 4]和3组合(最短耗时为5分钟)，[2 + 3]和4组合(总耗时为6),[3 + 4]和2组合(最短耗时为5)
'''
```

那么如何实现**[2+3]和4**或者**[2+4]和3**这种组合就成了关键，我尝试了其他的多种数据的情况

```python
2 4 3 
'''
如果有多个题目，那么需要两两分组，但是两两分组后
两组的和又不能相差太多
如本组数据中，[2 + 4]和3组合(总耗时为7分组)，[2 + 3]和4组合(总耗时为7),[3 + 4]和2组合(总耗时为6)
'''
5 7 6
'''
5 + 7和6  最短耗时11分钟
5 + 6和7  最短耗时11分钟
6 + 7和5  最短耗时11分钟
'''
7 8 9
'''
7 + 8和9	总耗时为17
8 + 9和7	总耗时为16
7 + 9和8	总耗时为17
'''
```

经过观察发现，耗时最短的情况，单科耗时最短的情况，总是耗时最少的单提出来

非常适合使用**贪心算法**（就是优先吃掉大的）

---

所以，我们可以先进行排序，下面是我们判定的规则

注意：下面的`+`号表示组合，而不是让它俩相加

+ `# 数字组：2 4 3`

  > 按从大到小排序`4 3 2`

+ `# 数字组：5 7 6`

  > 按从大到小排序`7 6 5`

+ `# 数字组：7 8 9`

  > 按从大到小排序`9 8 7`

---

`for`循环实现

```python
# 此代码实现了累加里面的数据
my_class = [2, 4, 3]
sum = 0
my_class.sort(reverse=True)	# 按照降序排序
for i in range(len(my_class)):
    sum += my_class[i]
print(sum)
```

但是，我们的需求是

+ 两个数据为一组（不满两个单列一组），求出所需的最小时间

+ 多个数据的情况下，我们不能让大脑保持空闲

  > 比如：`2 4 3`，所谓的最短时间是：同时计算耗时4分钟和2分钟或3分钟的
  > 4 & 2，在2分钟的率先算完以后，再续上3分钟的，一共耗时五分钟
  > 4 & 3，在3分钟的率先算完以后，再续上2分钟的，一共耗时五分钟

根据如上描述，我们的思路是：

定义两个变量`sum_A`和`sum_B`，均赋初始值为`0`，我们在累加前进行判断，让它俩竞争，谁时间少，就把时间加到谁的身上

# 代码

> 注意：此代码关键部分说明如下

比如刚开始`sum_A`和`sum_B`均为`0`

以数据源：`2 4 3`为例，排序后`4 3 2`

+ 首先给A赋值为我们时间数组中耗时最久的时间（也就是模拟A大脑）`sum_A = 4`

+ 在第二轮循环中，我们的`sum_A=4`肯定是大于`sum_B=0`的，
  进入`else`，给`sum_B=0`赋值数组第二个元素`sum_B=3`（注意我们的数组是降序）
+ 在第三轮循环中，我们的`sum_A=4`还是大于`sum_B=3`，于是再进入`else`，为`sum_B`累加一个`2`，`sum_B=5` 

```python
my_class = [2, 4, 3]
sum_A = 0
sum_B = 0
my_class.sort(reverse=True)	# 按照降序排序
for i in range(len(my_class)):
    if sum_A <= sum_B:
        sum_A += my_class[i]
    else:
        sum_B +=my_class[i]
print(sum_A)
print(sum_B)
```

注意，`sum_A`和`sum_B`是三组数据二合一后的，得到的数据为`4`和`5`

此时，4分钟为`A`大脑算完一道题，5为`B`大脑算完两道题，共耗时5分钟

然后我们需要一个全局变量，累加一下我们的所有科目的时间

关于这个写法在4位数表现如何？

```python
my_class = [2, 4, 3, 7]
sum_A = 0
sum_B = 0
my_class.sort(reverse=True)  # 按照降序排序
for i in range(len(my_class)):
    if sum_A <= sum_B:
        sum_A += my_class[i]
    else:
        sum_B += my_class[i]
print(sum_A)
print(sum_B)

```

```shell
9
7
```

可以看到，A大脑耗时9分钟，B大脑耗时7分钟，一共耗时9分钟

---

> 完整思路

+ 创建一个代码，直接定义好好我们最后要输出的结果
  ```python
  ans = 0
  if __name__ == "__main__":
      print(f'一共耗时{ans}')
  ```

  ```shell
  一共耗时0
  ```

+ 首先我们看到题目，应该首先做的事情是接受数据
  ```python
  ans = 0
  if __name__ == "__main__":
      '''
      接受所有科目的题目数量
      '''
      my_class = list(map(int, input("输入所有科目的题目数量：").split()))
      print(my_class) # 验证一下是否接受成功，下一步删除
      print(f'一共耗时{ans}')
  ```

  ```shell
  输入所有科目的题目数量：1 2 1 3
  [1, 2, 1, 3]
  一共耗时0
  ```

+ 然后，根据每个科目的题目数量，输入每个科目的每个题目需要消耗的时间
  ```python
  ans = 0
  if __name__ == "__main__":
      '''
      接受所有科目的题目数量
      '''
      my_class = list(map(int, input("输入所有科目的题目数量：").split()))
      for i in range(len(my_class)):
          my_class_spend_time = list(map(int, input("输入每个科目的单个题目所需的时间：").split()))
          print(my_class_spend_time)  # 验证是否接受成功，下一步删除
  
      print(f'一共耗时{ans}')
  ```

  ```shell
  输入所有科目的题目数量：1 2 1 3
  输入每个科目的单个题目所需的时间：5
  [5]
  输入每个科目的单个题目所需的时间：4 3
  [4, 3]
  输入每个科目的单个题目所需的时间：6
  [6]
  输入每个科目的单个题目所需的时间：2 4 3
  [2, 4, 3]
  一共耗时0
  ```

+ 对每个单科的时间进行排序
  ```python
  ans = 0
  if __name__ == "__main__":
      '''
      接受所有科目的题目数量
      '''
      my_class = list(map(int, input("输入所有科目的题目数量：").split()))
      for i in range(len(my_class)):
          my_class_spend_time = list(map(int, input("输入每个科目的单个题目所需的时间：").split()))
          my_class_spend_time.sort(reverse=True)
          print(my_class_spend_time)  # 验证是否排序成功，下一步删除
  
      print(f'一共耗时{ans}')
  ```

  ```python
  输入所有科目的题目数量：1 2 1 3
  输入每个科目的单个题目所需的时间：5
  [5]
  输入每个科目的单个题目所需的时间：4 3
  [4, 3]
  输入每个科目的单个题目所需的时间：6
  [6]
  输入每个科目的单个题目所需的时间：2 4 3
  [4, 3, 2]
  一共耗时0
  ```

+ 获取没科最短时间
  ```python
  ans = 0
  if __name__ == "__main__":
      '''
      接受所有科目的题目数量
      '''
      my_class = list(map(int, input("输入所有科目的题目数量：").split()))
      for i in range(len(my_class)):
          my_class_spend_time = list(map(int, input("输入每个科目的单个题目所需的时间：").split()))
          my_class_spend_time.sort(reverse=True)
          sum_A = 0   # 模拟A大脑
          sum_B = 0   # 模拟B大脑
          for j in range(len(my_class_spend_time)):
              if sum_A <= sum_B:
                  sum_A += my_class_spend_time[j]
              else:
                  sum_B += my_class_spend_time[j]
          print(max(sum_A,sum_B))	# 验证是否获取成功，下一步删除
      print(f'一共耗时{ans}')
  
  ```

  ```shell
  输入所有科目的题目数量：1 2 1 3
  输入每个科目的单个题目所需的时间：5
  5
  输入每个科目的单个题目所需的时间：4 3
  4
  输入每个科目的单个题目所需的时间：6
  6
  输入每个科目的单个题目所需的时间：2 4 3
  5
  一共耗时0
  ```

+ 累加每科最短时间
  ```python
  ans = 0
  if __name__ == "__main__":
      '''
      接受所有科目的题目数量
      '''
      my_class = list(map(int, input("输入所有科目的题目数量：").split()))
      for i in range(len(my_class)):
          my_class_spend_time = list(map(int, input("输入每个科目的单个题目所需的时间：").split()))
          my_class_spend_time.sort(reverse=True)
          sum_A = 0  # 模拟A大脑
          sum_B = 0  # 模拟B大脑
          for j in range(len(my_class_spend_time)):
              if sum_A <= sum_B:
                  sum_A += my_class_spend_time[j]
              else:
                  sum_B += my_class_spend_time[j]
          ans += max(sum_A, sum_B)
      print(f'一共耗时{ans}')
  ```

  ```shell
  输入所有科目的题目数量：1 2 1 3
  输入每个科目的单个题目所需的时间：5
  输入每个科目的单个题目所需的时间：4 3
  输入每个科目的单个题目所需的时间：6
  输入每个科目的单个题目所需的时间：2 4 3
  一共耗时20
  ```

  

